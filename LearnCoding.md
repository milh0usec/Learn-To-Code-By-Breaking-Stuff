# Learn To Be a Full-Stack Software Developer by Breaking Stuff

## Why Develop Software?

Until about five years I never heard the acronym [STEM](https://en.wikipedia.org/wiki/Science,_Technology,_Engineering,_and_Mathematics): Science, Technology, Engineering, and Mathematics. Now I hear it all the time, usually in the context of telling young people that if they don't study STEM they'll never get a job.

You could go to college and study four years for an engineering or math degree You could study  ten plus years for a science doctorate. Technology, in contrast, can be learned in a few months at a coding bootcamp. Coding bootcamps are springing up like mushrooms after a spring rain in a cow pasture. [Course Report] (http://www.coursereport.com) lists 313 full-stack web development coding bootcamps, 122 mobile development bootcamps, 76 data science bootcamps, 41, digital marketing bootcamps, and 40 product management bootcamps, as of February 21, 2016.

Coding bootcamps range from ten weeks to twenty-four weeks. Tuition varies from $9,500 to $21,000. The good news is that hiring managers at tech companies increasingly say that they prefer to hire coding bootcamp graduates over four-year university computer science (CS) graduates.

> The traditional, classically trained computer science graduate is actually becoming, I would say, a minority among my peers and among the people I interact with.” — Dave Smith (JavaScript Jabber 183,  “Should I go to college?” 10:54. This podcast goes into depth about the shortcomings of university computer science programs.)

The tl;dr ("too long; didn't read") is that CS programs teach theoretical, perhaps outdated, material such as writing your own operating system. Technology is changing so fast that what a freshman learns may be obsolete four years later. Coding bootcamps teach the practical skills needed to write software now.

Software development can be a sweet job. The pay is good, starting above $60,000/year and reaching $120,000/year within five years. The job market is strong and growing. Many software companies treat coders well, with flexible hours and free beer.

Coding is just fun. If you like creativity and problem-solving you'll like coding.

Even if you don't especially like coding, or lack a natural talent for it, a background in coding will help many other careers. For example, an English major who can code can be a technical writer. A business major who can code can be a product manager. The middle-aged women who used to be office managers are now scrum masters.

## Why Not Software Development

On the other hand, information technology (IT) can be a soul-killing corporate job. I've talked to top IT professionals who are paid very well and hate their jobs. Dilbert is a software engineer (Scott Adams, Dilbert's creator, was a software engineer at Pacific Bell from 1986 to 1995).

And some coding bootcamps oversell their placement rates. Galvanize, where I went to school, claims a 97% six-month placement rate with an average starting salary of $77,000. My class of 25 students graduated October 1, 2015. Three months later twelve students were working full-time as software developers and four were hired by Galvanize. Another student was working part-time as a software developer. Six of us were unemployed. Two students dropped out of sight. That's about a 70% placement rate. Today, four and half months after graduation, three more students have jobs, or 85%.

I saw no relationship between ability to code and getting a job. Of the top students, one took an internship immediately after graduation. A second got a job in 2.5 months, a third was hired, in 3.5 months, and a fourth just got a job, after 4.5 months.

One of these top students is a young woman whose previous job was a waitress. She studied hard, didn't go out to the bars with the other students, and rose to the top of the class. Another student has twenty years experience as a software engineer and took six months off from his career (in dev ops at a large IT company) to learn the latest software. He took a position as a senior developer at a mid-size tech company. He then asked to hire the young woman as his junior developer. She passed the technical interviews with flying colors. The company low-balled her at $44,000/year. The senior developer objected, saying that she was worth at least $80,000. The hiring manager raised the offer to $52,000 but said that there was no way they were paying a waitress anything more.

There are endless job openings for senior developers (five or more years experience) with specialized skills. Few companies want to hire junior developers (less than three years experience) without specialized skills. Software is the most complex thing humans make. Most careers, e.g., an optometrist, require a few skills that are used repetitively for years, but a software developer is using typically eight major technologies, one or more of which is new and must be learned. A company may be willing to hire a developer who knows seven of the eight technologies they need and can learn the eighth, but they're not going to hire a junior developer who only knows one or two, and then only at an intermediate or beginner level.

Large companies such as American Express have internship or training programs to bring in CS or bootcamp graduates, train them for a few months, and then put them to work with a mentor and other support. But most tech companies are small or otherwise lack the resources to bring in junior developers.

The tech industry is also notoriously biased towards young white or Asian men. If you're over 40, a woman, or a different race, expect your job search to take longer.

## Why Not A Coding Bootcamp?

OK, you've decided to go for a coding career. Go to [Course Report] (http://www.coursereport.com), read the reviews of coding bootcamps, pick one, borrow between $9,500 and $21,000, work hard for three to six months, and then use the school's placement officer to help you find a job.

Or choose online courses such as [Code School](https://www.codeschool.com/), [Codecademy](https://www.codecademy.com/), or the free [Odin Project](http://www.theodinproject.com/). Or just buy stacks of technical books from [O'Reilly](http://www.oreilly.com/), [Packt](https://www.packtpub.com/), etc. Work at your own pace and don't go into debt.

Coding bootcamps and online courses have their problems. To be an effective software developer you need three types of skills:

* Technical skills
* Social skills
* Time management skills

Let's start with the time management skills. If you're easily bored or distracted you'll never get anywhere with the online courses or books. Humans are social animals. Sitting in a classroom from 9am to 5pm every day with 25 students pushing through a curriculum is better for most people.

On the other hand, few, if any, coding bootcamps teach time management skills. You'd be better off explicitly studying time management techniques such as the [Pomodoro Technique] (https://en.wikipedia.org/wiki/Pomodoro_Technique) or installing time-management software on your computer.

Social skills are essential for software development. Gone are the days when software engineers sat alone in cubicles late into the night. Being in a class of 25 students enables you to learn social skills such as pair programming and asking and answering questions. A better term for what I mean would be "peer-recognized skills" as I include design (e.g., making your website look beautiful) and presentation skills (public speaking). But, again, few coding bootcamps teach social skills. In my class at Galvanize some students paired up with a friend for the course, and everyone else worked alone.

And of course there are the technical skills: JavaScript, databases, design, etc. This is the curriculum of coding bootcamps. The broad outlines are fairly standard among coding bootcamps, e.g., a MEAN stack coding bootcamp will teach MongoDB, Express, Angular, and Node, the devil can be in the details. For example, my Galvanize class didn't learn jQuery or Bootstrap. These libraries are standard in any production JavaScript environment. We spent weeks learning routing in Node without Express, which is never done in production.

My impression is that the short (ten-week or twelve-week) coding bootcamps have better curricula than the long coding bootcamps (twenty-four weeks). The short courses have to efficiently teach what's needed, when the long courses can afford to teach stuff no one would do in production, such as CSS positioning without Bootstrap or Node routing without Express. By extension, four-year CS programs take this further, teaching students to write their own operating systems, etc.

### Teaching Methodologies

While no coding bootcamp curriculum is perfect, the curriculum is usually the least of problems at a coding bootcamp. The biggest problem is usually teaching methodologies. The University of Colorado (a few blocks from my house) has a [Physics Education Research Group](http://www.colorado.edu/per/). PER@C doesn't teach physics. The group researches best practices for teaching physics. The tl;dr is, an instructor standing in front of a screen and students sitting in rows isn't how students learn. The best teaching method has students sitting in pairs or small groups. The instructor presents a short lecture and then asks a question. The students have a minute or two to silently formulate their own answer, then they vote with their clickers, then they discuss their answers with their partners, then the instructor presents the answer.

Coding is similar to physics in some ways but different in others. A big difference is that physics has clear questions with right and wrong answers. If you use [Stack Overflow](http://stackoverflow.com) you'll see that coding questions are rarely simple. Explaining what you're trying to do, what's happening, what the error messages are, and your stack of technologies isn't simple. Then people give you ten solutions to your problem, usually involving libraries or stack technologies you're not using.

Coding is more about creative problem-solving, i.e., finding multiple ways to solve a problem and choosing the best solution. I have a radical idea for teaching coding. I sit down with you and I'll teach you something, one on one. Then you document (write) everything you learned. Then you teach someone else. Then everyone takes an exam to prove they've learned it.

I proposed this to two coding bootcamps. I suggested admitting four students each week. In the mornings the second-week students teach the first-week students, the fourth-week students teach the third-week students, etc. In the afternoons the third-week students teach the second-week students, etc. Fridays every takes exams. If you pass you move on; if not you do the week again.

Both coding bootcamps had the same response: my ideas are too radical, and I should start my own coding bootcamp.

### Complexity Is the Enemy

I said that software development is the most complex activity humans do. Galvanize has an explicit policy to increase the complexity of assignments, to get students used to working with complexity. Specifically, each assignment requires two or three new concepts, but the instructor teaches only one of the new concepts. The students are expected to "figure out" the other new concepts on their own. My classmates hated this but we were told that this is what software developers have to do every day.

Experienced developers can "figure out" new stuff on their own but beginners can't. There are too many places to get stuck and too many rabbit holes to go down. The result is that students think there is a single solution to a problem. They are afraid to experiment because any change could break something somewhere else. Experimentation is how we learn, and complexity kills experimentation.

I believe in making lessons as simple as possible. Students then feel comfortable experimenting with other ways to solve a problem. That's what effective software developers do.

### Reading, Writing, and Breaking Stuff

Our lead instructor at Galvanize is a gifted speaker. I can happily listen to him talk all day about coding. But the next day I don't remember what he said. I'm just not an auditory learner. I'm a kinesthetic learner (see "The Open Mind," by Dawna Marcova, about auditory, visual and kinesthetic learning styles), I learn by taking things apart and putting them back together.

When working with non-physical concepts such as software writing is a part of my learning process. Writing helps me to organize and structure what I learned. Even making a simple checklist is a big help:

1. Do this step first.
2. Next do this step.
3. This is the third step.
4. The fourth step is last.

At Galvanize we had a CRUD exam at 22 weeks. We had 7.5 hours to make a simple database app with create, read, update, and delete functions. I spent the previous five days studying. I spent three days making a CRUD app and documenting each step. Then I spent two days following my instructions to make another CRUD app, while correcting and improving my instructions.

I broke down CRUD apps into the simplest steps (reduce complexity). Each step finished with a test. If the code didn't pass the test I could go back and look at a few lines of code to see where the problem was.

The next day was the exam. I followed my instructions and had my app functional after lunch. I then spent the afternoon adding extra Angular features and funny pictures from the Internet into my database. I never got stuck and I had a smile on my face the entire day.

Half the class failed the exam. No one else had written extensive documentation. I was also the only student who used Angular (everyone else used Handlebars).

The following week we had an object-oriented programming (OOP) exam. Again I wrote extensive documentation, I passed, and half the class failed.

I believe that writing is an important part of learning to code. Writing encourages students to experiment, i.e., break stuff. When you organize your knowledge by writing you see other ways to do things. You naturally want to list every way to solve a problem. You don't think there's a "single solution" to a problem.

### What's Wrong With Technical Books

University classes have textbooks. Coding bootcamps don't. While there are thousands of technical books and blogs on any coding topic, and I've bought hundreds, I find it difficult to learn coding from a book.

For example, I recently wanted to learn D3.js, the data visualization library. I bought five books, plus read the [D3](https://d3js.org) website. Four of the books were too advanced. One book ("Interactive Data Visualization for the Web," by Scott Murray) was for beginners. It was a tutorial, taking you step by step through the basic charts. But I had a specific type of chart in mind, and Murray's tutorial didn't teach how to make my chart, so I had to experiment outside of his tutorial. Some chapters I wanted to skip, e.g., I wanted to make a bar chart so I didn't want to read the chapter about line charts, but essential material was buried in the line chart chapter so I couldn't skip it. Other materials was missing and I had to search outside the book.

When I was a technical writer I learned that there are four types of documentation:

* Teachers like an overview of the field, explaining the philosophy behind it.
* Engineers like reference materials, where they can quickly look up everything about a specific topic.
* Secretaries like contextual help buttons (PC era) or tooltips (web era, the little rollover popup help windows).
* Marketing people like tutorials.

Technical books typically mix up all this, aiming for everyone and pleasing no one. And I'll add another type of reader: students need problem sets to work through. I rarely see problem sets in technical books.

I proposed that technical documentation should be written thus:

1. An introductory chapter with an overview of the field. Taking a lesson from startup pitches, what are the pain points, how were these problems solved in the past, and how does the subject better solve those problems? This chapter should contain no essential info so that readers in a hurry can skip it.
2. A tutorial, or rather a series of single-chapter tutorials. Each tutorial is short, simple and teaches one concept.
3. Each tutorial chapter ends with a problem set for students to learn by doing and experimentation.
4. The tutorials are independent and organized so that you can skip some. Each tutorial starts with its prerequisites, i.e., which chapters must be read before this chapter.
4. The last part of the book is a reference manual. This tells you everything about a subject, and the subjects are organized so as to be easy to find. The tutorial chapters have hyperlinks to the references when new terms are introduced.
6. I've never seen tool tips in technical books. I'll think about this one!

## My Proposal

I propose an online coding bootcamp:

* You see a list of students who are online waiting for a partner (presence). Each user lists the subjects he or she can teach and the subjects he or she wants to learn. E.g., I want to learn Express routing, Bootstrap, and MongoDB; and I can teach Angular, SQL, and CSS styling.
* You select a partner and open a video conferencing window. You can also share screens and files.
* Extensive documentation is available on every topic.
* You and your partner select a topic and work through the documentation together. The teacher partner helps the student partner.
* At the end of each session each student gives bonus points to his or her partner. If you complete more tutorials you get more points. Bonus points can be given for good teaching, asking good questions, good pair programming, beautiful design, making your partner laugh, etc.
* Students learn to write good documentation. Each subject has a wiki and students can contribute to the tutorials, references, problem sets, etc. Students receive bonus points for contributing.
* Students can add new subjects, e.g., a new database or framework.
* Students can also translate the wikis into other languages, and receive points for this. Users can select partners by language.
* Exams are available to prove proficiency and get gold stars.
* A "Stack Overflow"-like forum for students to ask (and answer) questions specific to problem sets or assignments.
* When you graduate you receive a data-driven resume showing what subjects you've mastered,  your ranking among all students for each social skill (e.g., how many sessions you've taught, how many questions you've answered, whether you partnered with one person or with many), and your ranking for time-management skills (e.g., how much time you spent reading documentation, writing documentation, coding, etc.).
* The job placement area is a wiki listing companies that hire coders. You get points for adding companies to the list. Job-seekers can select local companies, read short descriptions of each company, and click through to the careers page for a company and see all the open positions at the company. Students can also leave comments about companies and interviews.
* The job placement area includes different careers, e.g., QA and testing, product manager, scrum master, etc. Students can add tutorials for careers other than coding.
